import{BufferAttribute as e,BufferGeometry as t,Float32BufferAttribute as r,InstancedBufferAttribute as i,InterleavedBuffer as o,InterleavedBufferAttribute as n,TriangleFanDrawMode as u,TriangleStripDrawMode as s,TrianglesDrawMode as l,Vector3 as a}from"three";function computeMikkTSpaceTangents(t,r,i=!0){if(!r||!r.isReady)throw Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!t.hasAttribute("position")||!t.hasAttribute("normal")||!t.hasAttribute("uv"))throw Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function o(e){if(e.normalized||e.isInterleavedBufferAttribute){let t=new Float32Array(e.count*e.itemSize);for(let r=0,i=0;r<e.count;r++)t[i++]=e.getX(r),t[i++]=e.getY(r),e.itemSize>2&&(t[i++]=e.getZ(r));return t}return e.array instanceof Float32Array?e.array:new Float32Array(e.array)}let n=t.index?t.toNonIndexed():t,u=r.generateTangents(o(n.attributes.position),o(n.attributes.normal),o(n.attributes.uv));if(i)for(let s=3;s<u.length;s+=4)u[s]*=-1;return n.setAttribute("tangent",new e(u,4)),t!==n&&t.copy(n),t}function mergeGeometries(e,r=!1){let i=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),u={},s={},l=e[0].morphTargetsRelative,a=new t,f=0;for(let m=0;m<e.length;++m){let g=e[m],d=0;if(i!==(null!==g.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+m+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(let c in g.attributes){if(!o.has(c))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+m+'. All geometries must have compatible attributes; make sure "'+c+'" attribute exists among all geometries, or in none of them.'),null;void 0===u[c]&&(u[c]=[]),u[c].push(g.attributes[c]),d++}if(d!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+m+". Make sure all geometries have the same number of attributes."),null;if(l!==g.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+m+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(let b in g.morphAttributes){if(!n.has(b))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+m+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===s[b]&&(s[b]=[]),s[b].push(g.morphAttributes[b])}if(r){let p;if(i)p=g.index.count;else{if(void 0===g.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+m+". The geometry must have either an index or a position attribute"),null;p=g.attributes.position.count}a.addGroup(f,p,m),f+=p}}if(i){let h=0,$=[];for(let A=0;A<e.length;++A){let y=e[A].index;for(let w=0;w<y.count;++w)$.push(y.getX(w)+h);h+=e[A].attributes.position.count}a.setIndex($)}for(let x in u){let B=mergeAttributes(u[x]);if(!B)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+x+" attribute."),null;a.setAttribute(x,B)}for(let T in s){let E=s[T][0].length;if(0===E)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[T]=[];for(let z=0;z<E;++z){let G=[];for(let v=0;v<s[T].length;++v)G.push(s[T][v][z]);let S=mergeAttributes(G);if(!S)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+T+" morphAttribute."),null;a.morphAttributes[T].push(S)}}return a}function mergeAttributes(t){let r,i,o,n=-1,u=0;for(let s=0;s<t.length;++s){let l=t[s];if(void 0===r&&(r=l.array.constructor),r!==l.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===i&&(i=l.itemSize),i!==l.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=l.normalized),o!==l.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(-1===n&&(n=l.gpuType),n!==l.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;u+=l.count*i}let a=new r(u),f=new e(a,i,o),m=0;for(let g=0;g<t.length;++g){let d=t[g];if(d.isInterleavedBufferAttribute){let c=m/i;for(let b=0,p=d.count;b<p;b++)for(let h=0;h<i;h++){let $=d.getComponent(b,h);f.setComponent(b+c,h,$)}}else a.set(d.array,m);m+=d.count*i}return void 0!==n&&(f.gpuType=n),f}export function deepCloneAttribute(t){return t.isInstancedInterleavedBufferAttribute||t.isInterleavedBufferAttribute?deinterleaveAttribute(t):t.isInstancedBufferAttribute?new i().copy(t):new e().copy(t)}function interleaveAttributes(e){let t,r=0,i=0;for(let u=0,s=e.length;u<s;++u){let l=e[u];if(void 0===t&&(t=l.array.constructor),t!==l.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;r+=l.array.length,i+=l.itemSize}let a=new o(new t(r),i),f=0,m=[],g=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"];for(let c=0,b=e.length;c<b;c++){let p=e[c],h=p.itemSize,$=p.count,A=new n(a,h,f,p.normalized);m.push(A),f+=h;for(let y=0;y<$;y++)for(let w=0;w<h;w++)A[d[w]](y,p[g[w]](y))}return m}export function deinterleaveAttribute(t){let r=t.data.array.constructor,o=t.count,n=t.itemSize,u=t.normalized,s=new r(o*n),l;l=t.isInstancedInterleavedBufferAttribute?new i(s,n,u,t.meshPerAttribute):new e(s,n,u);for(let a=0;a<o;a++)l.setX(a,t.getX(a)),n>=2&&l.setY(a,t.getY(a)),n>=3&&l.setZ(a,t.getZ(a)),n>=4&&l.setW(a,t.getW(a));return l}export function deinterleaveGeometry(e){let t=e.attributes,r=e.morphTargets,i=new Map;for(let o in t){let n=t[o];n.isInterleavedBufferAttribute&&(i.has(n)||i.set(n,deinterleaveAttribute(n)),t[o]=i.get(n))}for(let u in r){let s=r[u];s.isInterleavedBufferAttribute&&(i.has(s)||i.set(s,deinterleaveAttribute(s)),r[u]=i.get(s))}}function estimateBytesUsed(e){let t=0;for(let r in e.attributes){let i=e.getAttribute(r);t+=i.count*i.itemSize*i.array.BYTES_PER_ELEMENT}let o=e.getIndex();return t+(o?o.count*o.itemSize*o.array.BYTES_PER_ELEMENT:0)}function mergeVertices(e,t=1e-4){t=Math.max(t,Number.EPSILON);let r={},i=e.getIndex(),o=e.getAttribute("position"),n=i?i.count:o.count,u=0,s=Object.keys(e.attributes),l={},a={},f=[],m=["getX","getY","getZ","getW"],g=["setX","setY","setZ","setW"];for(let d=0,c=s.length;d<c;d++){let b=s[d],p=e.attributes[b];l[b]=new p.constructor(new p.array.constructor(p.count*p.itemSize),p.itemSize,p.normalized);let h=e.morphAttributes[b];h&&(a[b]||(a[b]=[]),h.forEach((e,t)=>{let r=new e.array.constructor(e.count*e.itemSize);a[b][t]=new e.constructor(r,e.itemSize,e.normalized)}))}let $=.5*t,A=Math.log10(1/t),y=Math.pow(10,A),w=$*y;for(let x=0;x<n;x++){let B=i?i.getX(x):x,T="";for(let E=0,z=s.length;E<z;E++){let G=s[E],v=e.getAttribute(G),S=v.itemSize;for(let I=0;I<S;I++)T+=`${~~(v[m[I]](B)*y+w)},`}if(T in r)f.push(r[T]);else{for(let _=0,X=s.length;_<X;_++){let R=s[_],U=e.getAttribute(R),H=e.morphAttributes[R],k=U.itemSize,M=l[R],V=a[R];for(let N=0;N<k;N++){let Y=m[N],Z=g[N];if(M[Z](u,U[Y](B)),H)for(let P=0,D=H.length;P<D;P++)V[P][Z](u,H[P][Y](B))}}r[T]=u,f.push(u),u++}}let W=e.clone();for(let C in e.attributes){let L=l[C];if(W.setAttribute(C,new L.constructor(L.array.slice(0,u*L.itemSize),L.itemSize,L.normalized)),C in a)for(let q=0;q<a[C].length;q++){let O=a[C][q];W.morphAttributes[C][q]=new O.constructor(O.array.slice(0,u*O.itemSize),O.itemSize,O.normalized)}}return W.setIndex(f),W}function toTrianglesDrawMode(e,t){if(t===l)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t!==u&&t!==s)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e;{let r=e.getIndex();if(null===r){let i=[],o=e.getAttribute("position");if(void 0===o)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let n=0;n<o.count;n++)i.push(n);e.setIndex(i),r=e.getIndex()}let a=r.count-2,f=[];if(t===u)for(let m=1;m<=a;m++)f.push(r.getX(0)),f.push(r.getX(m)),f.push(r.getX(m+1));else for(let g=0;g<a;g++)g%2==0?(f.push(r.getX(g)),f.push(r.getX(g+1)),f.push(r.getX(g+2))):(f.push(r.getX(g+2)),f.push(r.getX(g+1)),f.push(r.getX(g)));f.length/3!==a&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");let d=e.clone();return d.setIndex(f),d.clearGroups(),d}}function computeMorphedAttributes(e){let t=new a,i=new a,o=new a,n=new a,u=new a,s=new a,l=new a,f=new a,m=new a;function g(e,r,a,g,d,c,b,p){t.fromBufferAttribute(r,d),i.fromBufferAttribute(r,c),o.fromBufferAttribute(r,b);let h=e.morphTargetInfluences;if(a&&h){l.set(0,0,0),f.set(0,0,0),m.set(0,0,0);for(let $=0,A=a.length;$<A;$++){let y=h[$],w=a[$];0!==y&&(n.fromBufferAttribute(w,d),u.fromBufferAttribute(w,c),s.fromBufferAttribute(w,b),g?(l.addScaledVector(n,y),f.addScaledVector(u,y),m.addScaledVector(s,y)):(l.addScaledVector(n.sub(t),y),f.addScaledVector(u.sub(i),y),m.addScaledVector(s.sub(o),y)))}t.add(l),i.add(f),o.add(m)}e.isSkinnedMesh&&(e.applyBoneTransform(d,t),e.applyBoneTransform(c,i),e.applyBoneTransform(b,o)),p[3*d+0]=t.x,p[3*d+1]=t.y,p[3*d+2]=t.z,p[3*c+0]=i.x,p[3*c+1]=i.y,p[3*c+2]=i.z,p[3*b+0]=o.x,p[3*b+1]=o.y,p[3*b+2]=o.z}let d=e.geometry,c=e.material,b,p,h,$=d.index,A=d.attributes.position,y=d.morphAttributes.position,w=d.morphTargetsRelative,x=d.attributes.normal,B=d.morphAttributes.position,T=d.groups,E=d.drawRange,z,G,v,S,I,_,X,R=new Float32Array(A.count*A.itemSize),U=new Float32Array(x.count*x.itemSize);if(null!==$){if(Array.isArray(c))for(z=0,v=T.length;z<v;z++)for(_=Math.max((I=T[z]).start,E.start),X=Math.min(I.start+I.count,E.start+E.count),G=_,S=X;G<S;G+=3)b=$.getX(G),g(e,A,y,w,b,p=$.getX(G+1),h=$.getX(G+2),R),g(e,x,B,w,b,p,h,U);else for(_=Math.max(0,E.start),X=Math.min($.count,E.start+E.count),z=_,v=X;z<v;z+=3)b=$.getX(z),g(e,A,y,w,b,p=$.getX(z+1),h=$.getX(z+2),R),g(e,x,B,w,b,p,h,U)}else if(Array.isArray(c))for(z=0,v=T.length;z<v;z++)for(_=Math.max((I=T[z]).start,E.start),X=Math.min(I.start+I.count,E.start+E.count),G=_,S=X;G<S;G+=3)b=G,g(e,A,y,w,b,p=G+1,h=G+2,R),g(e,x,B,w,b,p,h,U);else for(_=Math.max(0,E.start),X=Math.min(A.count,E.start+E.count),z=_,v=X;z<v;z+=3)b=z,g(e,A,y,w,b,p=z+1,h=z+2,R),g(e,x,B,w,b,p,h,U);let H=new r(R,3),k=new r(U,3);return{positionAttribute:A,normalAttribute:x,morphedPositionAttribute:H,morphedNormalAttribute:k}}function mergeGroups(e){if(0===e.groups.length)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),e;let t=e.groups;if(t=t.sort((e,t)=>e.materialIndex!==t.materialIndex?e.materialIndex-t.materialIndex:e.start-t.start),null===e.getIndex()){let r=e.getAttribute("position"),i=[];for(let o=0;o<r.count;o+=3)i.push(o,o+1,o+2);e.setIndex(i)}let n=e.getIndex(),u=[];for(let s=0;s<t.length;s++){let l=t[s],a=l.start,f=a+l.count;for(let m=a;m<f;m++)u.push(n.getX(m))}e.dispose(),e.setIndex(u);let g=0;for(let d=0;d<t.length;d++){let c=t[d];c.start=g,g+=c.count}let b=t[0];e.groups=[b];for(let p=1;p<t.length;p++){let h=t[p];b.materialIndex===h.materialIndex?b.count+=h.count:(b=h,e.groups.push(b))}return e}function toCreasedNormals(t,r=Math.PI/3){let i=Math.cos(r),o=(1+1e-10)*100,n=[new a,new a,new a],u=new a,s=new a,l=new a,f=new a;function m(e){let t=~~(e.x*o),r=~~(e.y*o),i=~~(e.z*o);return`${t},${r},${i}`}let g=t.index?t.toNonIndexed():t,d=g.attributes.position,c={};for(let b=0,p=d.count/3;b<p;b++){let h=3*b,$=n[0].fromBufferAttribute(d,h+0),A=n[1].fromBufferAttribute(d,h+1),y=n[2].fromBufferAttribute(d,h+2);u.subVectors(y,A),s.subVectors($,A);let w=new a().crossVectors(u,s).normalize();for(let x=0;x<3;x++){let B=n[x],T=m(B);T in c||(c[T]=[]),c[T].push(w)}}let E=new Float32Array(3*d.count),z=new e(E,3,!1);for(let G=0,v=d.count/3;G<v;G++){let S=3*G,I=n[0].fromBufferAttribute(d,S+0),_=n[1].fromBufferAttribute(d,S+1),X=n[2].fromBufferAttribute(d,S+2);u.subVectors(X,_),s.subVectors(I,_),l.crossVectors(u,s).normalize();for(let R=0;R<3;R++){let U=n[R],H=m(U),k=c[H];f.set(0,0,0);for(let M=0,V=k.length;M<V;M++){let N=k[M];l.dot(N)>i&&f.add(N)}f.normalize(),z.setXYZ(S+R,f.x,f.y,f.z)}}return g.setAttribute("normal",z),g}export{computeMikkTSpaceTangents,mergeGeometries,mergeAttributes,interleaveAttributes,estimateBytesUsed,mergeVertices,toTrianglesDrawMode,computeMorphedAttributes,mergeGroups,toCreasedNormals};